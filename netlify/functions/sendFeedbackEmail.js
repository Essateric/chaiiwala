// sendFeedbackEmail.js (ESM + Netlify-compatible)
import nodemailer from 'nodemailer';
import { PDFDocument, rgb, StandardFonts, PDFName, PDFArray } from 'pdf-lib';
import path from 'path';
import fs from 'fs';

import dotenv from 'dotenv';
dotenv.config();

console.log('EMAIL_USER:', process.env.EMAIL_USER || '‚ùå Not Set');
console.log('üõ†Ô∏è FUNCTION BOOTED ‚úÖ');

async function generateRealPDF(htmlContent, fileName) {
  const pdfDoc = await PDFDocument.create();
  let page = pdfDoc.addPage([595.28, 841.89]);
  let { width, height } = page.getSize();
  const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const boldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const textContent = stripHtmlAndFormat(htmlContent);
  let yPosition = height - 50;
  const lineHeight = 20;
  const margin = 50;
  const maxWidth = width - margin * 2;

  for (const line of textContent.lines) {
    if (yPosition < 50) {
      page = pdfDoc.addPage([595.28, 841.89]);
      yPosition = page.getSize().height - 50;
    }

    const currentFont = line.bold ? boldFont : font;
    const fontSize = line.heading ? 16 : 12;
    const words = line.text.split(' ');
    let currentLine = '';

    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      const textWidth = currentFont.widthOfTextAtSize(testLine, fontSize);
      if (textWidth > maxWidth && currentLine) {
        drawLine(page, currentLine, yPosition, fontSize, currentFont, line.link);
        yPosition -= lineHeight;
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }

    if (currentLine) {
      drawLine(page, currentLine, yPosition, fontSize, currentFont, line.link);
      yPosition -= lineHeight + (line.heading ? 10 : 0);
    }
  }

  const pdfBytes = await pdfDoc.save();
  return {
    buffer: Buffer.from(pdfBytes),
    fileName: `${fileName}.pdf`,
    size: pdfBytes.length
  };
}

function drawLine(page, text, y, fontSize, font, link) {
  const margin = 50;
  const textWidth = font.widthOfTextAtSize(text, fontSize);
  const color = link ? rgb(0, 0, 1) : rgb(0, 0, 0);

  page.drawText(text, {
    x: margin,
    y,
    size: fontSize,
    font,
    color
  });

  if (link) {
    const context = page.doc.context;

    const uriAction = context.obj({
      Type: PDFName.of('Action'),
      S: PDFName.of('URI'),
      URI: context.obj(link)
    });

    const linkAnnotation = context.obj({
      Type: PDFName.of('Annot'),
      Subtype: PDFName.of('Link'),
      Rect: context.obj([margin, y, margin + textWidth, y + fontSize]),
      Border: context.obj([0, 0, 0]),
      A: uriAction
    });

    let annots = page.node.lookup(PDFName.of('Annots'), PDFArray);

    if (!annots) {
      annots = context.obj([]);
      page.node.set(PDFName.of('Annots'), annots);
    }

    annots.push(linkAnnotation);
  }
}



function stripHtmlAndFormat(html) {
  const lines = [];
  const cleanText = html.replace(/<br\s*\/?>/gi, '\n').replace(/<\/(p|div|h[1-6])>/gi, '\n');
  const textLines = cleanText.split('\n');

  for (const line of textLines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    const linkMatch = trimmed.match(/<a\s+href=["']([^"']+)["'][^>]*>(.*?)<\/a>/i);
    if (linkMatch) {
      const [, url, text] = linkMatch;
      lines.push({ text: text.trim(), bold: false, heading: false, link: url });
      continue;
    }

    const isHeading = /<h[1-6][^>]*>/i.test(trimmed);
    const isBold = /<b[^>]*>|<strong[^>]*>/i.test(trimmed);
    const cleanLine = trimmed.replace(/<[^>]*>/g, '');
    if (cleanLine) lines.push({ text: cleanLine, bold: isBold, heading: isHeading });
  }

  return { lines };
}

async function sendRealEmail(pdfBuffer, fileName, recipientEmail = 'essateric@gmail.com') {
  const emailUser = process.env.EMAIL_USER;
  const emailPass = process.env.EMAIL_PASS;
  if (!emailUser || !emailPass) {
    throw new Error('Missing EMAIL_USER or EMAIL_PASS');
  }

  const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: emailUser,
      pass: emailPass
    },
    debug: true,
    logger: true
  });

  await transporter.verify();

  const mailOptions = {
    from: emailUser,
    to: 'usman.aftab@chaiiwala.co.uk',
    cc: [
      'essateric@gmail.com'
    ],
    subject: `Chaiiwala Customer Feedback - ${fileName}`,
    text: `PDF "${fileName}" attached.\n\nGenerated by Essateric Solutions`,
    html: `<h2>Chaiiwala Customer Feedback Submission</h2><p>PDF "<strong>${fileName}</strong>" is attached.</p>`,
    attachments: [
      {
        filename: fileName,
        content: pdfBuffer,
        contentType: 'application/pdf'
      }
    ]
  };

  const info = await transporter.sendMail(mailOptions);
  return { success: true, messageId: info.messageId, response: info.response };
}

const formatRating = (r) => (!r || r === 0 ? 'Not Rated' : `${r}/5 ${'*'.repeat(r)}`);

const generateFeedbackHTML = (d) => `
<h1>Chaiiwala Customer Feedback Form</h1>
<p><strong>Store Location:</strong> ${d.location || 'Not specified'}</p>
<p><strong>Visit Date:</strong> ${d.visit_date || 'Not specified'}</p>
<p><strong>Customer Name:</strong> ${d.customer_name || 'Anonymous'}</p>
<h2>Service Quality</h2>
<p><strong>Order Read Back:</strong> ${d.order_read_back || 'Not specified'}</p>
<p><strong>Cutlery Provided:</strong> ${d.cutlery_provided || 'Not specified'}</p>
<p><strong>Staff In Uniform:</strong> ${d.staff_in_uniform || 'Not specified'}</p>
<p><strong>Friendly Greeting:</strong> ${formatRating(d.friendly_greeting)}</p>
<p><strong>Staff Chewing Gum:</strong> ${d.staff_chewing_gum || 'Not specified'}</p>
<h2>Experience Ratings</h2>
<p><strong>Customer Experience:</strong> ${formatRating(d.customer_experience)}</p>
<p><strong>Display Presentable:</strong> ${formatRating(d.display_presentable)}</p>
<p><strong>Customer Area Clean:</strong> ${formatRating(d.customer_area_clean)}</p>
<p><strong>Shop Vibe:</strong> ${formatRating(d.shop_vibe)}</p>
<h2>Environment</h2>
<p><strong>Temperature:</strong> ${d.temperature_suitable || 'Not specified'}</p>
<p><strong>Hot Drink Temperature:</strong> ${d.hot_drink_temperature || 'Not specified'}</p>
<h2>Food & Drink</h2>
<p><strong>Food and Drink Quality:</strong> ${formatRating(d.food_drink_quality)}</p>
<p><strong>Description:</strong> ${d.food_drink_description || 'Not provided'}</p>
<p><strong>Offered Other Items:</strong> ${d.offered_other_items || 'Not specified'}</p>
<h2>Additional Information</h2>
<p><strong>Staff Work Activities:</strong> ${d.staff_work_activities || 'Not specified'}</p>
<p><strong>Additional Comments:</strong> ${d.additional_comments || 'No additional comments'}</p>
<h2>Food Images</h2>
<p>${(d.food_images || []).map((url, i) => `<a href="${url}" target="_blank">Image ${i + 1}</a>`).join('<br>') || 'No images uploaded'}</p>
`.trim();

const generateFeedbackFileName = (d) => {
  const name = (d.customer_name || 'Anonymous').replace(/[^a-zA-Z0-9]/g, '_');
  const date = (d.visit_date || new Date().toISOString().split('T')[0]).replace(/[^0-9-]/g, '');
  return `${name}_${date}`;
};

export async function handler(event) {
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 204, headers: corsHeaders, body: '' };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: corsHeaders,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    console.log('üì• Received event:', event);
    console.log('üì¶ Body:', event.body);

    let payload;
    try {
      payload = JSON.parse(event.body || '{}');
    } catch (jsonErr) {
      return {
        statusCode: 400,
        headers: corsHeaders,
        body: JSON.stringify({ error: 'Invalid JSON in request body.' })
      };
    }

    if (payload.location || payload.customer_name) {
      const htmlContent = generateFeedbackHTML(payload);
      const fileName = generateFeedbackFileName(payload);

      let pdfResult;
      try {
        pdfResult = await generateRealPDF(htmlContent, fileName);
      } catch (err) {
        console.error('‚ùå PDF generation failed:', err);
        return {
          statusCode: 500,
          headers: corsHeaders,
          body: JSON.stringify({ error: 'PDF generation failed', detail: err.message })
        };
      }

      const score = Number(payload.customer_experience || 0);
      const recipient = score >= 4 && payload.location && payload.customer_name
        ? 'usman.aftab@chaiiwala.co.uk'
        : 'essateric@gmail.com';

      let emailResult;
      try {
        emailResult = await sendRealEmail(pdfResult.buffer, pdfResult.fileName, recipient);
      } catch (emailError) {
        console.error('‚ùå Failed to send email:', emailError);
        return {
          statusCode: 500,
          headers: corsHeaders,
          body: JSON.stringify({ error: 'Email send failed', detail: emailError.message })
        };
      }

      return {
        statusCode: 200,
        headers: corsHeaders,
        body: JSON.stringify({
          success: true,
          message: 'PDF generated and email sent.',
          emailSent: emailResult.success,
          recipient,
          fileName: pdfResult.fileName
        })
      };
    }

    return {
      statusCode: 400,
      headers: corsHeaders,
      body: JSON.stringify({ error: 'Missing required feedback data.' })
    };
  } catch (err) {
    console.error('‚ùå Unexpected server error:', err);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ error: err.message || 'Internal Server Error' })
    };
  }
}
